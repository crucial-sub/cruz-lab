---
title: "Stock Lab"
description: "WebSocket 기반 실시간 퀀트 투자 시뮬레이션 & AI 분석 플랫폼"
longDescription: "복잡한 퀀트 투자를 누구나 쉽게 경험할 수 있는 웹 플랫폼입니다. WebSocket을 활용해 13초 소요되는 시뮬레이션 과정을 실시간으로 시각화하여 대기 시간의 지루함을 해소하고, SSE 기반의 AI 챗봇을 통해 투자 전략에 대한 인사이트를 실시간으로 제공합니다."
image: "../../assets/img/projects/placeholder.svg"
tags:
  - "FinTech"
  - "Real-time"
  - "Data Visualization"
  - "Team Project"
tech:
  - "Next.js"
  - "TypeScript"
  - "WebSocket"
  - "Server-Sent Events"
  - "TanStack Query"
  - "Zustand"
  - "Recharts"
github: "https://github.com/Krafton-Jungle-10-Final-Project/Stock-Lab"
featured: true
order: 1
startDate: 2024-11-01
endDate: 2024-12-06
---


# Stock Lab: 실시간 퀀트 투자 플랫폼 개발기

크래프톤 정글 5개월 차, 파이널 프로젝트로 **'Stock Lab'**이라는 퀀트 투자 시뮬레이션 플랫폼을 개발하게 되었다.
5주 동안 5명의 팀원(FE 1, BE 4)과 함께 진행했으며, 프론트엔드 리드를 맡아 겪었던 **'실시간 데이터 처리'**에 대한 고민과 해결 과정을 공유해보고자 한다.

특히 **WebSocket**과 **SSE(Server-Sent Events)**를 둘 다 적용해보며 느낀 점, 그리고 "무조건 양방향 통신이 정답은 아니다"라는 기술적 회고를 담았다.

---

## 1. 30초의 침묵을 관전의 재미로 (WebSocket)

### 문제: 사용자는 기다려주지 않는다 ⏳

우리 서비스의 핵심 기능은 **백테스트(Backtest)**다.
유저가 투자 전략을 세우고 "시뮬레이션 시작"을 누르면, 서버는 과거 10년 치 주가 데이터를 분석하여 수익률을 계산한다. 데이터 양이 방대하다 보니 평균 **13~15초**, 길게는 30초까지 소요되는 무거운 작업이었다.

초기 접근은 단순했다. 로딩 스피너를 띄우고 **2초 간격으로 폴링(Polling)**을 하는 방식이었다.

```typescript
// 초기 접근: 2초 간격 Polling
useQuery({
  queryKey: ['status'],
  queryFn: checkStatus,
  refetchInterval: 2000 // 2초마다 상태 확인
});
```

하지만 이 방식에는 치명적인 문제가 있었다.
1.  **불안감**: 15초 동안 화면에 아무런 변화가 없으니 사용자는 "멈춘 것 아닌가?"라는 불안감을 느낀다.
2.  **비효율**: 완료 시점까지 계속 요청을 보낼 뿐만 아니라, 완료 후에는 **누적된 전체 데이터**를 한 번에 받아와야 해서 네트워크 리소스 낭비가 심했다.

### 해결: WebSocket으로 실시간 중계하기 📡

이 문제를 해결하기 위해 **WebSocket**을 도입하여 과정을 '스포츠 중계'처럼 시각화하기로 결정했다.

#### A. 준비 단계 세분화
서버가 작업을 수행 중임을 명확히 보여주기 위해, 준비 과정을 4단계로 세분화하여 실시간으로 전달받았다.
`가격 데이터 로딩` → `재무 데이터 로딩` → `팩터 계산` → `준비 완료`

서버에서 단계가 변경될 때마다 소켓 메시지를 전송하면, 클라이언트는 진행 바(Progress Bar)와 문구를 즉시 업데이트한다. 이를 통해 유저는 현재 어떤 작업이 진행 중인지 인지하고 안심할 수 있게 되었다.

#### B. 증분 데이터 전송 (Incremental Streaming)
가장 큰 성과는 데이터 전송 방식의 개선이다. 폴링 방식은 매 요청마다 데이터가 누적되어 전송량이 늘어나는 구조였다.

WebSocket을 통해 **"방금 계산된 1일 치 결과"**만 전송받도록 변경했다.
프론트엔드에서는 기존 차트 배열에 새로 수신한 데이터만 `push`하여 렌더링한다. 결과적으로 **중복 전송량 0%**를 달성했으며, 차트가 실시간으로 그려지는 역동적인 애니메이션 효과까지 얻을 수 있었다.

### 🤔 회고: 꼭 WebSocket이어야 했을까?

구현을 마친 후 데이터 흐름을 다시 분석해보니 흥미로운 점을 발견했다.

- **클라이언트 → 서버**: 연결 시 `ping` 외에는 전송 데이터 없음.
- **서버 → 클라이언트**: 진행 상황, 차트 데이터를 지속적으로 전송.

이는 전형적인 **단방향 통신**의 형태다. 사실 이 정도 요구사항이라면 무거운 WebSocket 대신 **SSE(Server-Sent Events)**가 더 가벼운 선택지였을 수 있다.

하지만 WebSocket 선택이 틀린 것은 아니었다.
1.  백엔드 팀이 이미 소켓 서버를 구축해둔 상태였고,
2.  향후 "시뮬레이션 중단 요청" 등 양방향 통신이 필요한 기능 확장을 고려했을 때 적절한 선택이었다고 판단된다.

---

## 2. AI 챗봇에게 타이핑 효과 가르치기 (SSE)

### 문제: 턴제 게임 같은 답답함 🐢

Stock Lab에는 AI 투자 비서 기능이 있다. 문제는 LLM(거대 언어 모델)이 답변을 생성하는 데 **5~10초** 가량 소요된다는 점이다.

초기에 일반 HTTP 요청(`POST`)으로 구현했을 때는, AI가 답변 생성을 완료할 때까지 유저가 **빈 말풍선**만 보고 있어야 했다. 이는 대화의 맥을 끊고 사용자 경험을 저해하는 요인이었다.

### 해결: SSE로 토큰 단위 스트리밍 🌊

ChatGPT처럼 글자가 타닥타닥 생성되는 **스트리밍(Streaming)** 효과를 구현하기 위해 **SSE(Server-Sent Events)**를 도입했다.

#### 기술적 의사결정: Fetch vs EventSource

여기서 한 가지 기술적 고민이 있었다. 보통 SSE는 브라우저 표준인 `EventSource` API를 사용하는데, 이는 **GET 요청만 지원한다**는 제약이 있다.

AI 질문에는 긴 프롬프트와 컨텍스트 데이터가 포함되므로 `POST` 요청이 필요할 수 있다. 그래서 처음에는 `fetch` API로 `POST` 요청을 보내고 `ReadableStream`으로 응답을 읽어오는 방식(ChatGPT 방식)을 고려했다.

하지만 우리 서비스의 프롬프트 길이를 분석해본 결과, GET 요청의 쿼리 파라미터 한도 내에서 충분히 처리가 가능했다. 따라서 복잡하게 스트림 리더를 직접 구현하기보다, **브라우저가 자동 재연결(Auto-Reconnect)을 지원하는 표준 `EventSource`**를 사용하는 것이 안정성 측면에서 유리하다고 판단했다.

```typescript
// useChatStream.ts (예시)
const eventSource = new EventSource(`/api/chat?prompt=${message}`);

eventSource.onmessage = (event) => {
  // 토큰 단위로 수신하여 기존 텍스트에 추가
  setResponse((prev) => prev + event.data);
};
```

결과는 성공적이었다. 첫 글자가 0.5초 만에 렌더링되면서 체감 대기 시간이 획기적으로 줄어들었고, 타자기 효과를 통해 실제 대화하는 듯한 생동감을 줄 수 있었다.

---

## 3. 마치며: 데이터를 그리는 사람 vs 흐름을 설계하는 사람

이번 프로젝트를 통해 프론트엔드 개발자의 역할이 단순히 API 데이터를 화면에 뿌리는 것에 그치지 않음을 깨달았다.

같은 데이터라도 **"어떤 프로토콜로 가져올지"**, **"사용자에게 어떤 방식으로 보여줄지"**를 고민하는 과정에서 서비스의 퀄리티가 결정된다. 30초의 지루한 대기 시간을 '관전의 재미'로 바꾸고, 끊기던 대화를 실시간으로 연결하면서 기술적 최적화가 사용자 경험에 미치는 영향을 체감할 수 있었다.

비슷한 고민을 하는 개발자라면, 무작정 최신 기술을 도입하기보다 **"데이터의 흐름이 어떤 형태인가?"**를 먼저 정의하고 그에 맞는 기술을 선택해보길 권한다.

---

*더 자세한 코드가 궁금하다면 [GitHub 레포지토리](https://github.com/Krafton-Jungle-10-Final-Project/Stock-Lab)를 참고하자.*