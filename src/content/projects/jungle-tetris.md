---
title: "Jungle Tetris"
description: "Canvas API + Socket.IO 기반 실시간 멀티플레이어 테트리스"
longDescription: "3박 4일 해커톤에서 개발한 실시간 대전 테트리스 게임입니다. DOM 조작의 성능 한계를 극복하기 위해 Canvas API로 자체 게임 엔진을 구현하여 60fps 렌더링을 달성했으며, Socket.IO를 활용해 10ms 미만의 지연 시간으로 상대방 점수를 실시간 동기화하여 긴박감 넘치는 대전 경험을 제공합니다."
image: "../../assets/img/projects/placeholder.svg"
tags:
  - "Game"
  - "Real-time"
  - "Hackathon"
tech:
  - "JavaScript"
  - "Canvas API"
  - "Socket.IO"
  - "Flask"
  - "MongoDB"
github: "https://github.com/crucial-sub/jungle10-tetris"
featured: true
order: 3
startDate: 2024-08-01
endDate: 2024-08-04
---


# Jungle Tetris: Canvas API로 3일 만에 멀티 테트리스 만들기

크래프톤 정글에서 진행된 3박 4일 해커톤. 주제는 자유였다.
우리 팀은 "단순한 테트리스는 재미없으니, **실시간으로 서로 공격하는 멀티 대전 테트리스**를 만들어보자!"는 목표를 세웠다.

문제는 팀원 중 게임 개발 경험자가 전무했다는 것.
맨땅에 헤딩하며 게임 엔진부터 멀티플레이 서버까지 직접 구현했던 치열한 72시간의 기록을 정리해본다.

---

## 1. DOM으로 테트리스를 만들면 안 되는 이유

### 초기 시도: `div` 태그 200개 🧱

처음엔 단순하게 접근했다. 테트리스 판이 10x20 크기이니, `div` 200개를 배치하고 색상만 바꾸면 될 것이라 생각했다.

```html
<!-- 상상 속의 테트리스 구조 -->
<div class="grid">
  <div class="cell filled"></div>
  <div class="cell empty"></div>
  ...
</div>
```

하지만 블록을 움직이는 순간 **심각한 성능 저하**가 발생했다.
블록이 한 칸 이동할 때마다 `div`들의 스타일을 갱신해야 했고, 브라우저는 레이아웃 재계산(Reflow)과 다시 그리기(Repaint)를 반복하느라 과부하가 걸렸다. 뚝뚝 끊기는 화면을 보며 깨달았다. **"게임은 이렇게 만드는 게 아니구나."**

### 해결: Canvas API로 전환 🎨

이에 **HTML5 Canvas API**를 학습하여 도입했다.
Canvas는 화면 전체를 픽셀 단위로 제어하는 도화지와 같아 방식이 완전히 다르다.

1.  **State-Driven**: `[[0,0,1], [1,1,1]...]`와 같이 2차원 배열로 상태만 관리한다.
2.  **일괄 렌더링**: 매 프레임마다 `clearRect`로 화면을 지우고, 배열 상태를 기반으로 `fillRect`를 호출해 다시 그린다.

또한 `setInterval` 대신 **`requestAnimationFrame`**을 사용했다. 이는 브라우저의 렌더링 주기에 맞춰 함수를 실행하므로, 모니터 주사율(60Hz)에 동기화된 끊김 없는 움직임을 구현할 수 있었다.

---

## 2. "실시간"의 함정 (Socket.IO)

### 문제: 상대방이 언제 죽을지 모른다

멀티 테트리스의 핵심은 **상대방 화면을 실시간으로 확인하는 긴장감**이다.
초기엔 "1초마다 서버에 내 상태를 보내고 상대방 상태를 받아오면(Polling) 되지 않을까?"라고 생각했다.

하지만 게임에서 1초는 **영겁의 시간**이었다.
공격 아이템을 사용해도 상대방 화면엔 1초 뒤에 반영되어 타격감이 없었고, 이미 패배했는데 1초 뒤에 게임 오버가 뜨는 부자연스러운 상황이 발생했다.

### 해결: Socket.IO로 즉시성 확보 ⚡

이를 해결하기 위해 **Socket.IO**를 도입했다. HTTP 요청처럼 매번 연결을 맺는 것이 아니라, WebSocket 파이프라인을 유지하며 데이터 발생 시 즉시 전송하는 방식이다.

- **Room 기능**: 대전 상대를 동일한 방(Room)에 입장시킨다.
- **이벤트 전송**: 점수가 오르면 `game:score` 이벤트를 즉시 발송한다.
- **브로드캐스팅**: 서버는 해당 방의 다른 참여자에게만 데이터를 중계한다.

```javascript
// 내 점수 상승 시 이벤트 발송
socket.emit('game:score', { score: 1000 });

// (상대방 클라이언트) 이벤트 수신 즉시 게이지 업데이트
socket.on('game:score', (data) => updateOpponentGauge(data.score));
```

결과적으로 지연 시간이 10ms 수준으로 단축되어, 줄을 지우는 즉시 상대방 게이지가 상승하는 쫄깃한 타격감을 구현할 수 있었다.

---

## 3. 회고: 아쉬움과 배운 점

### 😅 "상대방 화면도 보여줄걸..."

발표 당시 코치님의 피드백이 기억에 남는다.
*"점수 게이지뿐만 아니라 상대방 블록이 쌓이는 모습도 보였으면 더 박진감 넘쳤겠는데요?"*

사실 우리도 고민했던 부분이다. 하지만 **"200개 셀 데이터를 매번 전송하면 데이터 크기가 너무 크지 않을까?"** 하는 우려 때문에 점수 동기화에 그쳤다.

나중에 알게 된 사실이지만 **Deterministic Lockstep**이라는 기법이 있다.
화면 전체를 보내는 대신, **"오른쪽 키 입력", "회전 키 입력" 등의 입력 신호(Input)**만 전송하고, 각 클라이언트에서 시뮬레이션을 똑같이 수행하여 화면을 동기화하는 방식이다.
추후 게임 개발 기회가 생긴다면 꼭 적용해보고 싶은 기술이다.

### 마무리

3일 밤샘의 결과물치곤 꽤 완성도 높은 게임이 나와 뿌듯했다.
무엇보다 프론트엔드 개발자가 주로 다루는 DOM 조작을 넘어, **픽셀 좌표 계산, 물리 충돌 감지, 소켓 통신**과 같은 로우 레벨의 작업을 경험하며 시야가 확장되는 것을 느꼈다.

역시 개발 실력은 맨땅에 헤딩할 때 가장 많이 성장하는 법이다. 🤕

---

*👉 [GitHub 레포지토리 구경하기](https://github.com/crucial-sub/jungle10-tetris)*